# get_suggestion_query 実装ガイド

**本機能は後日実装する**

## 📊 概要

パーソナルAIパートナーCocoroCore2において、自然で控えめな会話提案機能`get_suggestion_query`の実装ガイドです。

TODO: 心の声機能（CocoroShellのバブルで定期的に心の声表示）についても検討する


**目標**: 質問攻めにならない、自然なタイミングでの会話継続支援

## 🎯 MemOS原機能の分析

### 元の機能仕様
**ファイル**: `Reference/MemOS/src/memos/mem_os/product.py`  
**行番号**: L699-L750  
**クラス**: `MOSProduct`

```python
def get_suggestion_query(self, user_id: str, language: str = "zh") -> list[str]:
    """Get suggestion query from LLM.
    Args:
        user_id (str): User ID.
        language (str): Language for suggestions ("zh" or "en").
    Returns:
        list[str]: The suggestion query list.
    """
```

### 動作フロー
1. **最近の記憶取得**: `search("my recently memories", top_k=3)`
2. **プロンプト生成**: 言語に応じたテンプレート使用
3. **LLM生成**: 3つの提案クエリを生成
4. **JSON解析**: `{"query": ["提案1", "提案2", "提案3"]}`形式

### 元のプロンプトテンプレート
```python
# 日本語版（元は中国語）
suggestion_prompt = """
あなたは有用なアシスタントで、ユーザーの提案クエリ生成を支援します。
ユーザーの最近の記憶を取得し、
ユーザーが質問したい内容である提案クエリを生成してください。
ユーザーの最近の記憶：
{memories}
3つの提案クエリを日本語で生成してください。
出力はJSON形式で、キーは"query"、値は提案クエリのリストです。

例：
{{
    "query": ["クエリ1", "クエリ2", "クエリ3"]
}}
"""
```

## 🚫 問題点と改善方針

### 原機能の問題
1. **質問攻めリスク**: 常に3つの質問を提示
2. **AIっぽい表現**: 機械的な提案文
3. **タイミング制御なし**: いつでも提案してしまう
4. **学習機能なし**: ユーザーの反応を考慮しない

### 改善方針
1. **タイミング制御**: 適切な間隔での提案
2. **自然な表現**: 「そういえば」「ところで」等の自然な切り出し
3. **単発提案**: 1つずつの控えめな提案
4. **文脈考慮**: 会話の流れに沿った提案
5. **学習機能**: ユーザー反応に基づく頻度調整

## 🛠️ 実装設計

### 1. CocoroCore2への統合

**実装場所**: `src/core_app.py`

```python
class CocoroCore2App:
    def __init__(self, config: CocoroAIConfig):
        # 既存初期化処理...
        
        # 提案システム初期化
        self.suggestion_controller = SuggestionController(
            suggestion_interval=600,  # 10分間隔
            max_suggestions_per_hour=2  # 1時間に最大2回
        )
    
    async def get_natural_suggestion(
        self, 
        conversation_context: Optional[Dict] = None
    ) -> Optional[str]:
        """自然で控えめな会話提案を生成"""
        
        # 1. タイミングチェック
        if not self.suggestion_controller.should_suggest_now(conversation_context):
            return None
        
        # 2. 最近の記憶取得
        recent_memories = self.mos.search(
            "my recently memories", 
            user_id=self.default_user_id, 
            top_k=3
        )
        
        # 3. 自然な提案生成
        suggestion = await self._generate_natural_suggestion(recent_memories)
        
        # 4. 提案履歴記録
        self.suggestion_controller.record_suggestion()
        
        return suggestion
    
    async def _generate_natural_suggestion(self, memories) -> Optional[str]:
        """自然な表現での単発提案生成"""
        
        if not memories or not memories.get("text_mem"):
            return None
        
        memory_content = "\n".join([
            m.memory[:200] 
            for m in memories["text_mem"][0]["memories"][:3]
        ])
        
        suggestion_prompt = f"""
        ユーザーとの最近の会話内容:
        {memory_content}
        
        以下の条件で自然な話題転換を1つだけ提案してください：
        
        【条件】
        - 「そういえば」「ところで」などの自然な切り出しで始める
        - 質問形式ではなく、関心を示す程度の軽い表現
        - ユーザーが無視しても気まずくならない程度
        - 最近の会話内容に関連した話題
        - 50文字以内の短い文章
        
        【良い例】
        "そういえば、お仕事の件はその後いかがですか？"
        "ところで、写真撮影は最近できていますか？"
        
        【悪い例】
        "何について話しましょうか？"
        "他に質問はありますか？"
        
        提案が思い浮かばない場合は空文字を返してください。
        """
        
        try:
            # LLM経由で生成（MemOSのchat_llmを使用）
            messages = [{"role": "system", "content": suggestion_prompt}]
            response = self.mos.chat_llm.generate(messages)
            
            # 空文字や不適切な応答の場合はNoneを返す
            if not response.strip() or len(response) > 100:
                return None
                
            return response.strip()
            
        except Exception as e:
            self.logger.warning(f"Failed to generate suggestion: {e}")
            return None
```

### 2. タイミング制御システム

```python
class SuggestionController:
    """提案タイミングの制御"""
    
    def __init__(self, suggestion_interval: int = 300, max_suggestions_per_hour: int = 2):
        self.suggestion_interval = suggestion_interval  # 最小間隔（秒）
        self.max_suggestions_per_hour = max_suggestions_per_hour
        self.last_suggestion_time = 0
        self.suggestion_history = []  # タイムスタンプ履歴
        self.user_response_rate = 0.5  # 初期応答率
    
    def should_suggest_now(self, conversation_context: Optional[Dict] = None) -> bool:
        """提案すべきタイミングかを判定"""
        
        current_time = time.time()
        
        # 1. 最小間隔チェック
        if current_time - self.last_suggestion_time < self.suggestion_interval:
            return False
        
        # 2. 時間当たり制限チェック
        recent_suggestions = [
            t for t in self.suggestion_history 
            if current_time - t < 3600  # 1時間以内
        ]
        if len(recent_suggestions) >= self.max_suggestions_per_hour:
            return False
        
        # 3. 会話状況チェック
        if conversation_context:
            # アクティブな会話中は避ける
            if self._is_active_conversation(conversation_context):
                return False
            
            # ユーザーが忙しそうな時は避ける
            if self._detect_busy_signals(conversation_context):
                return False
        
        # 4. ユーザー応答率に基づく確率的判定
        import random
        return random.random() < self.user_response_rate
    
    def record_suggestion(self):
        """提案を記録"""
        current_time = time.time()
        self.last_suggestion_time = current_time
        self.suggestion_history.append(current_time)
        
        # 古い履歴を削除（24時間以上前）
        self.suggestion_history = [
            t for t in self.suggestion_history 
            if current_time - t < 86400
        ]
    
    def update_response_rate(self, user_responded: bool):
        """ユーザー応答に基づいて応答率を更新"""
        # 指数移動平均で更新
        alpha = 0.1
        if user_responded:
            self.user_response_rate = (1 - alpha) * self.user_response_rate + alpha * 1.0
        else:
            self.user_response_rate = (1 - alpha) * self.user_response_rate + alpha * 0.0
        
        # 応答率に基づいて間隔を調整
        if self.user_response_rate < 0.3:
            self.suggestion_interval = min(600, self.suggestion_interval * 1.2)  # 間隔を延ばす
        elif self.user_response_rate > 0.7:
            self.suggestion_interval = max(180, self.suggestion_interval * 0.9)  # 間隔を縮める
    
    def _is_active_conversation(self, context: Dict) -> bool:
        """アクティブな会話中かを判定"""
        # 最近のメッセージ頻度などで判定
        # 実装は会話履歴の構造に依存
        return False
    
    def _detect_busy_signals(self, context: Dict) -> bool:
        """ユーザーが忙しそうな兆候を検出"""
        # 短い返答、「忙しい」等のキーワードで判定
        # 実装は会話内容の解析に依存
        return False
```

### 3. API統合

**実装場所**: `src/api/endpoints.py`

```python
@router.get("/api/suggestion")
async def get_conversation_suggestion(
    core_app: CocoroCore2App = Depends(get_app_instance)
):
    """自然な会話提案を取得"""
    try:
        suggestion = await core_app.get_natural_suggestion()
        
        if suggestion:
            return StandardResponse(
                code=200,
                message="Suggestion generated",
                data={"suggestion": suggestion}
            )
        else:
            return StandardResponse(
                code=204,
                message="No suggestion at this time",
                data=None
            )
            
    except Exception as e:
        logger.error(f"Failed to get suggestion: {e}")
        return StandardResponse(
            code=500,
            message="Failed to generate suggestion",
            data=None
        )

@router.post("/api/suggestion/feedback")
async def record_suggestion_feedback(
    responded: bool,
    core_app: CocoroCore2App = Depends(get_app_instance)
):
    """提案に対するユーザー反応を記録"""
    try:
        core_app.suggestion_controller.update_response_rate(responded)
        
        return StandardResponse(
            code=200,
            message="Feedback recorded",
            data=None
        )
        
    except Exception as e:
        logger.error(f"Failed to record feedback: {e}")
        return StandardResponse(
            code=500,
            message="Failed to record feedback",
            data=None
        )
```

## 🎨 フロントエンド連携

### CocoroDock側での実装

```csharp
// 定期的な提案チェック（5分間隔）
private async void CheckForSuggestions()
{
    var response = await cocoroClient.GetSuggestionAsync();
    
    if (response.Code == 200 && response.Data?.Suggestion != null)
    {
        // 控えめに表示（通知ではなく、チャット欄の下部に小さく表示）
        ShowSuggestionBubble(response.Data.Suggestion);
    }
}

// ユーザーが提案に反応した場合
private async void OnSuggestionClicked(string suggestion)
{
    // 提案をチャット入力欄に設定
    ChatInputBox.Text = suggestion;
    
    // フィードバック送信
    await cocoroClient.RecordSuggestionFeedbackAsync(true);
}

// 提案を無視した場合（一定時間後）
private async void OnSuggestionIgnored()
{
    await cocoroClient.RecordSuggestionFeedbackAsync(false);
}
```

## 📊 期待効果

### 1. 自然な会話継続
- 会話が途切れそうな時の自然な話題提供
- ユーザーの過去の興味に基づいた関連話題

### 2. パーソナライゼーション
- ユーザーの反応パターンに基づく学習機能
- 個人に最適化された提案頻度

### 3. ユーザビリティ向上
- 質問攻めの回避
- 適度な間隔での控えめな提案

## 🛠️ 実装手順

### Phase 1: コア機能実装（3日）
1. `SuggestionController`クラス実装
2. `get_natural_suggestion`メソッド実装
3. 基本的なタイミング制御

### Phase 2: API統合（1日）
1. エンドポイント追加
2. レスポンス形式定義

### Phase 3: フロントエンド連携（2日）
1. CocoroDock側の定期チェック機能
2. 提案表示UI実装
3. フィードバック機能

### Phase 4: 調整・最適化（1日）
1. プロンプト調整
2. タイミング制御の微調整
3. ユーザーテスト

## 🎯 成功指標

- **適切な頻度**: 1時間に1-2回程度
- **高い応答率**: ユーザーが50%以上の提案に反応
- **自然な表現**: AIっぽくない親しみやすい提案文
- **学習効果**: ユーザーの好みに応じた頻度自動調整

---

**作成日**: 2025年8月2日  
**実装期間**: 1週間（7日）  
**担当**: CocoroCore2チーム